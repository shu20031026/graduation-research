\section{はじめに}
電離圏研究を目的とする短波ドップラー(HFD)の観測データは, 自然科学分野の研究のためオープンデータとして公開され自由な使用が許可されている. \\
現状, 当データの効率的な再利用を推進するためデータのグラフィカルな表示を行う数件のwebアプリケーションが開発されているが, その多くが開発運用やユーザーエクスペリエンス (以下 UX) 等の観点での問題点を抱えている. 
\\本研究では既存のアプリケーションからの新規アプリケーション作成に伴うデータ取得とページのルーティングを通したUX向上を行う.\\

\section{使用技術}
\subsection{Next.jsについて}
Next.jsとはVercel社が提供するWebフレームワークである.
JavaScriptのUIライブラリの一つであるReact.jsがベースとなっており, その最大の特徴の一つが多様なページレンダリング手法のサポートである.
このフレームワークは, 開発者がアプリケーションの特定のニーズに応じて最適なレンダリング戦略を選択できるように設計されている. \\
Next.jsのレンダリングオプションには, 一般的なクライアントサイドレンダリング(CSR)の他に, サーバサイドレンダリング（SSR）, スタティックジェネレーション（SG）、およびインクリメンタル静的再生成（ISR）が含まれる.\\
2024年現在, バージョン12系以前で用いられていたクライアントサイドでのレンダリングをデフォルトとしたPage Routerとバージョン13系で追加されたサーバーサイドでのレンダリングをデフォルトとしたApp Routerの2種類のRouting手法が存在する.
本研究ではPage Routerを用いることとした.

\subsection{ページレンダリング手法}
\subsubsection{ページレンダリングとは}
Webアプリケーションにおいてページレンダリングとは, ウェブサーバーまたはブラウザがHTML/CSS/JavaScriptなどのコードを解釈し, ユーザーのデバイス上で視覚的なページとして表示するプロセスのことである.
プロセス内の各ステップを実行するタイミング等により分類されており, 適切な手法を選定することによりサイトの高速化やユーザ体験の改良, SEOの改善等が期待できる.
次に代表的なレンダリング手法とそのメリット・デメリットについて記す.

\subsubsection{SSR}
SSR（サーバーサイドレンダリング）はウェブページのレンダリングをサーバー側で行う手法である.
この手法ではユーザーのリクエストに応じてサーバーがHTMLを生成し, 完成したページがクライアントに送信される. \\
SSRはリクエストが起きたタイミングでクライアントサイドと比較して高速なサーバーサイドでHTMLが生成されるため, 初回ページロードの速度を向上させSEO対策に有効である.
他にも完成されたHTMLが送信されるためSEOに強い点や, クライアントサイドのJavaScript実行環境に依存しにくい点がメリットである.
しかし, サーバー負荷が大きい点やページ間移動にリロードが伴う点, 後述するSGやISRと比較するとコンテンツの表示に時間が掛かる点等がデメリットとして存在する.

\subsubsection{SG}
SG（スタティックジェネレーション）は, ビルド時に静的なHTMLファイルを生成しておく手法である.
このアプローチではビルド時にすべてのページが静的なHTMLとして生成され, リクエストに応じてそのHTMLが提供される.\\
ビルド時にHTMLが生成されレスポンスの際にはそれを提供するだけのため非常に高速であることがメリットとしてあげられるが, ビルド後の変更が困難なため動的なページ生成には向かないというデメリットが存在する.

\subsubsection{ISR}
ISR（インクリメンタルスタティックリジェネレーション）は, 静的サイトの生成とサーバーサイドレンダリングを組み合わせた手法である. 
ISRでは, ビルド時に一部のページのみを静的に生成し残りのページはユーザーのリクエストに応じて生成されキャッシュされる. 
これにより, サイトのビルド時間を短縮しつつ動的なコンテンツの提供が可能となる.\\
静的生成と動的生成のバランスが取れパフォーマンスとコンテンツの更新の柔軟性が両立されているメリットがあるが, 再生成後初回リクエスト時のオーバーヘッドが大きく読み込みに時間がかかってしまう場合があるというデメリットが存在する.

\subsubsection{Next.jsにおけるページレンダリング}
Next.jsのページレンダリングは主にページコンポーネントのライフサイクルとデータ取得方法に依存する特徴があり, それらのレンダリング手法をページごとに異なる方法で適用できる柔軟性にも優れている.\\
例として一部のページはSSRを使用して動的にデータを取得を行い、他のページはSGを使用して静的に生成することも可能である.
このような柔軟性により開発者はパフォーマンス, SEO, ユーザーエクスペリエンスのバランスを取りつつ, アプリケーションの特定の要件に合わせて最適なレンダリング戦略を選択できる.
これにより, 開発者はより高速で対話的なウェブアプリケーションを構築することができ, 最終的にはユーザーに優れた体験を提供することが可能となる.

\subsection{スクレイピングについて}
このアプリケーションは, 各観測所にて観測されたデータを素のディレクトリ構造のまま公開されている既存のアプリケーションからデータをスクレイピングしてきて再描画を行うものである.
スクレイピングとはwebアプリケーションからHTMLデータをクローラによって取得し、必要とされる情報を抽出するする技術のことである.\\
スクレイピングの際には取得元のサイトの規約に乗っ取る義務がある.
今回の場合は取得先のデータがOSS化されていることと学術目的として取得先の団体からの許可を得ていることから, 過剰な負荷がかからない範囲内での利用が可能であると判断した.

\section{アプリケーション設計と実装方法}
\subsection{実装の要件}
本研究ではアプリケーション実装のうち外部データの取得とページの描画を主体としている.
そのためUX向上を目的とした,データフェッチからの画面描画速度の高速化を目標に設定した.\\
今回作成するアプリケーションのうち, webスクレイピングを伴うページは大きく分けて以下の2つである.\\
\begin{quote}
	\begin{itemize}
		\item 波形データの検索ページ
		\item 波形の描画ページ
	\end{itemize}
\end{quote}
これらのページの実装を行い、ビルド時間とスクレイピングのリクエスト数の2軸から最適化を行うものとした.

\subsection{スクレイピングに用いた関数}
今回実装したスクレイピング関数は大きく2つあり, 1つは指定した日時・観測所の周波数のCSVデータをJSON化して取得するもの, もう1つは存在するデータの一覧を取得するものである.
スクレイピング先のアプリケーションでは観測所・年度・日時の順にネストされたパスから周波数のデータを取得可能である. 
1つめの関数ではURLで具体的なデータの所在ページを指定した上でスクレイピングした.
2つめの関数では存在するページの一覧化のため観測所のひとつ上の階層から子要素となるページを再帰的に全探索する形でスクレイピングし整形を行った.

\subsection{レンダリング設計}
次にレンダリング設計について述べる.
以下の2パターンの設計で実装を行い、ビルド時間を比較し考察することとした.
\begin{quote}
	\begin{enumerate}
		\item ISRを用いる方法
		\item SGとSSRを用いる方法
	\end{enumerate}
\end{quote}
\subsubsection{ISRを用いる方法}
1つ目の手法はISRを用いた実装である.
この手法はビルドの際に一括でスクレイピング処理を完結させて静的なサイトを生成するものである.\\
実装方法はgetStaticPathsと呼ばれる関数内でディレクトリ一覧をスクレイピングし静的にビルドするページを確定させた上で, getStaticPropsという関数でそれら一つ一つのページの波形データを取得してビルドを行う.\\
またISR技術を用いて再ビルドのタイミングを制御することにより, 一定期間ごとに新しく追加されたデータも取得できるようにさせることができるようにする.

\subsubsection{SGとSSRを用いる方法}
2つ目の手法はSGとSSRを併用させる方法である.
この手法ではディレクトリの取得と波形データの取得をそれぞれSG・SSRをもちいて分離させる方法である.
実装方法はgetStaticPropsを用いて検索ページに存在するURLを静的に受け渡し, getServerSidePropsを用いて各ページでリクエスト時に波形データを返すというものである.

\subsection{実行環境}
今回の実行環境としたPCを表　に示す.\\
また使用したパッケージのバージョンを表　に示す.

\begin{table}[hbtp]
	\caption{実行環境}
	\label{table:data_type}
	\centering
	\begin{tabular}{lcr}
		\hline
		名称      & MacBookPro    \\
		CPU     & Apple M1 Max  \\
		メモリ     & 32GB          \\
		コマンドシェル & zsh (v1.85.1) \\
		\hline
	\end{tabular}
\end{table}

\begin{table}[hbtp]
	\caption{パッケージのバージョン}
	\label{table:data_type}
	\centering
	\begin{tabular}{lcr}
		\hline
		名称         & バージョン   \\
		\hline \hline
		Node.js    & 18.12.0 \\
		Next.js    & 13.0.6  \\
		TypeScript & 4.9.4   \\
		
		\hline
	\end{tabular}
\end{table}


\section{実装結果}
\subsection{スクレイピング関数の実行時間}
\subsection{静的ビルドの実行時間の比較}
\section{考察}
